# Бизнес логика приложения

## 1. Возрастные ограничения

### 1.1 Техническое задание 1

**Только совершеннолетние пользователи могут добавлять книги в книжную лавку, у которых возрастное ограничение больше 18**

Реализуем эту логику в методе `BooksService.createBook(dto: CreateBookDto)`:
1. Добавим недостающий аргумент в метод
2. Запросим пользователя, который делает запрос на создание книги, чтобы проверить его возраст 
3. Инжектируем нужные зависимости
4. Проверяем возраст и возрастные ограничения у книги - если ОК - создаем книгу, если нет - `ForbiddenException('too yang, Bro')`
5. Изменим настройку `{ nullable: true }` колонки `ownerId` сущности `Book`, 
теперь анонимный пользователь не может добавлять книги и мы будем хранить в "книге" `ownerId`
6. Делаем необходимые правки в контроллере
7. Проверяем на фронте

#### 1.1.1 Инкапсуляция бизнес логики в методах сущности
Обратим внимание, что метод сервиса содержит в себе работу с другими слоями (репозитории) и тут же описана бизнес логика приложения.  
Чтобы, например, протестировать бизнес логику, нам придется в тесты интегрировать БД, что предполагает дополнительные настройки и связывает тесты с БД, (зачем нам тестировать работу ОРМ в тестах, посвященных бизнес логике?)
Давайте декомпозируем код и вынесем бизнес логику по созданию книги в метод модели `Book` - это ведь доменная сущность, пускай она хранит в себе логику своего создания!  
Нам подойдет **статический метод**, так как он принадлежит самому классу (мы ведь хотим инкапсулировать логику по созданию экземпляра класса - метод экземпляра нам не подойдет - экземпляра еще нет!)
1. Создаем static метод `createBook()` класса `Book`, который в случае положительного исхода проверки бизнес требований создаст и вернет новый экземпляр класса `Book`
2. Уносим туда бизнес логику добавления новой книги и создания экзепляра класса `Book`
3. В сервисе вызываем метод `Book.createBook()` и передаем в него необходимые аргументы и просим репозиторий сохранить новую книгу
4. Теперь детали логики создания книги инкапсулированы в статическом методе-фабрике, который без труда можно покрыть unit тестами ;)

### 1.2 Техническое задание 2

**Только тот кто добавил книгу (owner) может ее изменить. Учесть, обновление книги должно работает как patch-запрос.**

*Примечание: PATCH — это один из HTTP методов, используемый для частичного обновления ресурса на сервере. 
В отличие от PUT, который обычно используется для полного обновления ресурса,
PATCH позволяет обновить только те поля или свойства ресурса, которые изменились.*

1. Создаем метод **экземпляра** класса `Book` *(??почему не статический ??)* `updateBook()` и передаем нужные аргументы
2. Реализуем в нем нужные проверки (бизнес требования). Не забываем про возможность частичного обновления книги.
3. Создаем `booksService.updateBook()`:
 - запрашиваем искомую книгу по id. Репозиторий возвращает нам экземпляр класса `Book`.
*Задача репозитория: пойти в БД, достать данные, создать экземпляр сущности с данными из БД - в нашем случае мы делегировали эту работу ОРМ*
 - Вызываем метод `book.updateBook()`
 - Просим  books repository сохранить обновленную книгу
4. В контроллере вешаем гард для проверки авторизации (по аналогии с создинием книги)
5. Проверяем на фронте

*Примечание:  
Инкапсуляция бизнес-логики в методы сущностей не всегда возможна в полной мере. 
Часто часть логики остается в сервисах (или специальных доменных сервисах). 
Однако, если такая возможность существует, рекомендуется выносить эту логику в отдельные методы сущностей.*

### 1.3 unit тесты для проверки логики предметной обрасти при создании и обновлении книги (Опционально)